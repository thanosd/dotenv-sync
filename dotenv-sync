#!/usr/bin/env bash
#
# dotenv-sync ‚Äî Bidirectional .env sync with 1Password.
#
# Reads .env-refresh.yaml for the mapping of 1Password items ‚Üî local .env files.
#
# Usage:
#   dotenv-sync pull  [--force]   Fetch from 1Password ‚Üí local .env files
#   dotenv-sync push  [--force]   Push local .env files ‚Üí 1Password
#   dotenv-sync diff              Show differences without making changes
#   dotenv-sync init              Create a .env-refresh.yaml config in the current directory
#   dotenv-sync update            Manually update to the latest version
#
set -euo pipefail

VERSION="1.0.0"
REPO_URL="https://github.com/thanosd/dotenv-sync"

# Where the script itself lives (for git-based auto-update)
SELF_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Config and targets are resolved relative to the current working directory
CONFIG_FILE="${PWD}/.env-refresh.yaml"
FORCE=false

# --- Colors ----------------------------------------------------------------
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
RESET=$'\033[0m'

# --- Helpers ----------------------------------------------------------------

info() { printf '%s%s  %s\n' "${CYAN}" "‚Ñπ" "${RESET}  $*"; }
warn() { printf '%s%s  %s\n' "${YELLOW}" "‚ö†" "${RESET}  $*"; }
error() { printf '%s%s  %s\n' "${RED}" "‚úñ" "${RESET}  $*"; }
ok() { printf '%s%s  %s\n' "${GREEN}" "‚úî" "${RESET}  $*"; }

# Extract keys (VAR_NAME) from a .env file/string, ignoring comments and blanks.
extract_keys() {
	grep -E '^[A-Za-z_][A-Za-z0-9_]*=' "$1" 2>/dev/null | cut -d= -f1 | sort
}

# Parse the YAML config. Outputs tab-separated lines of "op_item\ttarget".
parse_config() {
	local op_item="" target=""
	while IFS= read -r line; do
		[[ ${line} =~ ^[[:space:]]*# ]] && continue
		[[ -z ${line// /} ]] && continue

		if [[ ${line} =~ op_item:[[:space:]]*\"?([^\"]+)\"? ]]; then
			op_item="${BASH_REMATCH[1]}"
		elif [[ ${line} =~ target:[[:space:]]*\"?([^\"]+)\"? ]]; then
			target="${BASH_REMATCH[1]}"
			if [[ -n ${op_item} && -n ${target} ]]; then
				printf '%s\t%s\n' "${op_item}" "${target}"
			fi
			op_item=""
			target=""
		fi
	done <"${CONFIG_FILE}"
	return 0
}

# Fetch an item's notesPlain from 1Password. Returns content via stdout.
# Sets $fetch_ok to "true" or "false".
fetch_from_op() {
	local op_item="$1"
	local raw
	if ! raw=$(op item get "${op_item}" --fields notesPlain 2>&1); then
		error "Failed to fetch \"${op_item}\" from 1Password: ${raw}"
		return 1
	fi
	# Strip surrounding quotes that `op` sometimes adds
	echo "${raw}" | sed '1s/^"//;$s/"$//'
}

# Show a key-level analysis between two files.
show_key_analysis() {
	local file_a="$1" file_b="$2" label_a="$3" label_b="$4"

	local keys_a keys_b
	keys_a=$(extract_keys "${file_a}")
	keys_b=$(extract_keys "${file_b}")

	local only_a only_b
	only_a=$(comm -23 <(echo "${keys_a}") <(echo "${keys_b}"))
	only_b=$(comm -13 <(echo "${keys_a}") <(echo "${keys_b}"))

	if [[ -n ${only_a} ]]; then
		printf '\n  %sKeys only in %s (will be lost):%s\n' "${RED}${BOLD}" "${label_a}" "${RESET}"
		while IFS= read -r key; do
			[[ -n ${key} ]] && printf '    %s‚àí %s%s\n' "${RED}" "${key}" "${RESET}"
		done <<<"${only_a}"
	fi

	if [[ -n ${only_b} ]]; then
		printf '\n  %sKeys only in %s (will be added):%s\n' "${GREEN}${BOLD}" "${label_b}" "${RESET}"
		while IFS= read -r key; do
			[[ -n ${key} ]] && printf '    %s+ %s%s\n' "${GREEN}" "${key}" "${RESET}"
		done <<<"${only_b}"
	fi

	if [[ -z ${only_a} && -z ${only_b} ]]; then
		printf '\n  %sSame keys on both sides ‚Äî only values differ.%s\n' "${DIM}" "${RESET}"
	fi
}

# Show diff between two files with labels
show_diff() {
	local file_a="$1" file_b="$2" label_a="$3" label_b="$4"
	diff --color=always -u "${file_a}" "${file_b}" \
		--label "${label_a}" \
		--label "${label_b}" || true
}

# Prompt the user for an action. Returns 0 to proceed, 1 to skip.
prompt_user() {
	local target="$1" file_a="$2" file_b="$3" label_a="$4" label_b="$5"

	if ${FORCE}; then
		return 0
	fi

	while true; do
		printf '  %sApply changes to %s?%s [y]es / [n]o / [d]iff again: ' "${BOLD}" "${target}" "${RESET}"
		read -r choice </dev/tty
		case "${choice}" in
		y | Y | yes) return 0 ;;
		n | N | no) return 1 ;;
		d | D | diff)
			printf "\n"
			show_diff "${file_a}" "${file_b}" "${label_a}" "${label_b}"
			printf "\n"
			show_key_analysis "${file_a}" "${file_b}" "${label_a}" "${label_b}"
			printf "\n"
			;;
		*) warn "Please enter y, n, or d" ;;
		esac
	done
}

# --- Auto-update ------------------------------------------------------------

check_for_updates() {
	# Skip if not in a git repo (e.g. installed via copy)
	if [[ ! -d "${SELF_DIR}/.git" ]]; then
		return 0
	fi

	# Try to fetch latest from origin (silently fail if offline)
	if ! git -C "${SELF_DIR}" fetch --quiet origin main 2>/dev/null; then
		return 0
	fi

	local local_head remote_head
	local_head=$(git -C "${SELF_DIR}" rev-parse HEAD 2>/dev/null) || return 0
	remote_head=$(git -C "${SELF_DIR}" rev-parse origin/main 2>/dev/null) || return 0

	if [[ "${local_head}" == "${remote_head}" ]]; then
		return 0
	fi

	local behind
	behind=$(git -C "${SELF_DIR}" rev-list --count HEAD..origin/main 2>/dev/null) || behind="some"

	printf '\n%süÜï A new version of dotenv-sync is available!%s\n' "${YELLOW}${BOLD}" "${RESET}"
	printf '   %s(%s commit(s) behind)%s\n' "${DIM}" "${behind}" "${RESET}"
	printf '   %sRelease notes:%s %s\n\n' "${DIM}" "${RESET}" "${REPO_URL}/commits/main"

	printf '  %sUpdate now?%s [y]es / [n]o: ' "${BOLD}" "${RESET}"
	read -r choice </dev/tty
	case "${choice}" in
	y | Y | yes)
		info "Updating dotenv-sync..."
		if git -C "${SELF_DIR}" pull --ff-only origin main; then
			ok "Updated to the latest version!"
			info "Re-running your command with the new version...\n"
			exec "${SELF_DIR}/dotenv-sync" "$@"
		else
			warn "Fast-forward update failed. Run 'cd ${SELF_DIR} && git pull' manually."
		fi
		;;
	*)
		info "Skipping update. You can run 'dotenv-sync update' any time.\n"
		;;
	esac
}

cmd_update() {
	if [[ ! -d "${SELF_DIR}/.git" ]]; then
		error "dotenv-sync was not installed via git. Cannot auto-update."
		info "Re-install from: ${REPO_URL}"
		exit 1
	fi

	info "Fetching latest from ${REPO_URL}..."
	if ! git -C "${SELF_DIR}" fetch origin main; then
		error "Failed to fetch. Check your network connection."
		exit 1
	fi

	local local_head remote_head
	local_head=$(git -C "${SELF_DIR}" rev-parse HEAD)
	remote_head=$(git -C "${SELF_DIR}" rev-parse origin/main)

	if [[ "${local_head}" == "${remote_head}" ]]; then
		ok "Already up to date! (v${VERSION})"
		return 0
	fi

	local behind
	behind=$(git -C "${SELF_DIR}" rev-list --count HEAD..origin/main 2>/dev/null) || behind="some"
	info "${behind} new commit(s) available"

	if git -C "${SELF_DIR}" pull --ff-only origin main; then
		ok "Updated successfully!"
	else
		error "Fast-forward failed. You may have local changes."
		info "Run: cd ${SELF_DIR} && git pull"
		exit 1
	fi
}

cmd_init() {
	if [[ -f "${CONFIG_FILE}" ]]; then
		warn "Config file already exists: ${CONFIG_FILE}"
		printf '  %sOverwrite?%s [y]es / [n]o: ' "${BOLD}" "${RESET}"
		read -r choice </dev/tty
		if [[ ! ${choice} =~ ^[yY] ]]; then
			info "Cancelled."
			return 0
		fi
	fi

	cat >"${CONFIG_FILE}" <<'YAML'
# dotenv-sync configuration
# Maps 1Password Secure Note items to local .env files.
#
# Usage:
#   dotenv-sync pull   ‚Äî fetch from 1Password ‚Üí local files
#   dotenv-sync push   ‚Äî push local files ‚Üí 1Password
#   dotenv-sync diff   ‚Äî show differences

mappings:
  - op_item: "My App .env"
    target: ".env"

  # - op_item: "My App Production .env"
  #   target: ".env.production"
YAML

	ok "Created ${CONFIG_FILE}"
	info "Edit the file to map your 1Password items to local .env files, then run 'dotenv-sync pull'."
}

# --- Usage ------------------------------------------------------------------

usage() {
	cat <<EOF
${BOLD}dotenv-sync${RESET} v${VERSION} ‚Äî Bidirectional .env sync with 1Password

${BOLD}Usage:${RESET} dotenv-sync <command> [options]

${BOLD}Commands:${RESET}
  pull     Fetch .env files from 1Password ‚Üí local files
  push     Push local .env files ‚Üí 1Password
  diff     Show differences without making changes
  init     Create a .env-refresh.yaml config in the current directory
  update   Update dotenv-sync to the latest version

${BOLD}Options:${RESET}
  --force, -f     Apply all changes without prompting
  --version, -v   Show version
  --help,  -h     Show this help

${BOLD}Setup:${RESET}
  Place a ${CYAN}.env-refresh.yaml${RESET} in your project root. Example:

    mappings:
      - op_item: "MyApp Staging .env"
        target: ".env"
      - op_item: "MyApp Production .env"
        target: ".env.production"

${DIM}${REPO_URL}${RESET}
EOF
}

# --- Commands ---------------------------------------------------------------

cmd_pull() {
	printf '\n%s‚¨á  Pulling .env files from 1Password%s\n' "${BOLD}" "${RESET}"
	printf '%sConfig: %s%s\n\n' "${DIM}" "${CONFIG_FILE}" "${RESET}"

	local -a summary=()
	local count=0

	local config_lines
	config_lines=$(parse_config)

	while IFS=$'\t' read -r op_item target; do
		count=$((count + 1))
		local target_path="${PWD}/${target}"

		printf '%s‚îÅ‚îÅ‚îÅ [%s] %s%s\n' "${BOLD}" "${count}" "${target}" "${RESET}"
		info "1Password item: ${op_item}"

		local env_data fetch_rc
		set +e
		env_data=$(fetch_from_op "${op_item}")
		fetch_rc=$?
		set -e
		if [[ ${fetch_rc} -ne 0 ]]; then
			summary+=("${RED}‚úñ${RESET} ${target} ‚Äî failed to fetch")
			echo ""
			continue
		fi

		local tmp_file
		tmp_file=$(mktemp)
		printf '%s\n' "${env_data}" >"${tmp_file}"

		# Target doesn't exist ‚Äî just create it
		if [[ ! -f ${target_path} ]]; then
			mkdir -p "$(dirname "${target_path}")"
			cp "${tmp_file}" "${target_path}"
			ok "Created ${target} (new file)"
			summary+=("${GREEN}‚úî${RESET} ${target} ‚Äî created (new)")
			rm -f "${tmp_file}"
			echo ""
			continue
		fi

		# No changes
		if diff -q "${target_path}" "${tmp_file}" &>/dev/null; then
			ok "No changes for ${target}"
			summary+=("${DIM}‚Äî${RESET} ${target} ‚Äî no changes")
			rm -f "${tmp_file}"
			echo ""
			continue
		fi

		# Changes detected
		warn "Differences found for ${target}"
		printf "\n"
		show_diff "${target_path}" "${tmp_file}" "local: ${target}" "1password: ${op_item}"
		printf "\n"
		show_key_analysis "${target_path}" "${tmp_file}" "local" "1password"
		printf "\n"

		local prompt_rc
		set +e
		prompt_user "${target}" "${target_path}" "${tmp_file}" "local: ${target}" "1password: ${op_item}"
		prompt_rc=$?
		set -e
		if [[ ${prompt_rc} -eq 0 ]]; then
			cp "${tmp_file}" "${target_path}"
			ok "Updated ${target}"
			summary+=("${YELLOW}‚Üª${RESET} ${target} ‚Äî updated from 1Password")
		else
			info "Skipped ${target}"
			summary+=("${DIM}‚è≠${RESET} ${target} ‚Äî skipped")
		fi

		rm -f "${tmp_file}"
		echo ""
	done <<<"${config_lines}"

	print_summary "${count}" "${summary[@]}"
}

cmd_push() {
	printf '\n%s‚¨Ü  Pushing local .env files to 1Password%s\n' "${BOLD}" "${RESET}"
	printf '%sConfig: %s%s\n\n' "${DIM}" "${CONFIG_FILE}" "${RESET}"

	local -a summary=()
	local count=0

	local config_lines
	config_lines=$(parse_config)

	while IFS=$'\t' read -r op_item target; do
		count=$((count + 1))
		local target_path="${PWD}/${target}"

		printf '%s‚îÅ‚îÅ‚îÅ [%s] %s%s\n' "${BOLD}" "${count}" "${target}" "${RESET}"
		info "1Password item: ${op_item}"

		# Local file must exist to push
		if [[ ! -f ${target_path} ]]; then
			warn "Local file ${target} does not exist ‚Äî skipping"
			summary+=("${YELLOW}‚ö†${RESET} ${target} ‚Äî local file missing")
			echo ""
			continue
		fi

		# Fetch current 1Password content for comparison
		local remote_data item_exists=true fetch_rc
		set +e
		remote_data=$(fetch_from_op "${op_item}" 2>/dev/null)
		fetch_rc=$?
		set -e
		if [[ ${fetch_rc} -ne 0 ]]; then
			item_exists=false
		fi

		if ${item_exists}; then
			local tmp_remote
			tmp_remote=$(mktemp)
			printf '%s\n' "${remote_data}" >"${tmp_remote}"

			# No changes
			if diff -q "${target_path}" "${tmp_remote}" &>/dev/null; then
				ok "No changes for ${target}"
				summary+=("${DIM}‚Äî${RESET} ${target} ‚Äî no changes")
				rm -f "${tmp_remote}"
				echo ""
				continue
			fi

			# Changes detected ‚Äî show diff (remote ‚Üí local, since we're pushing local up)
			warn "Local ${target} differs from 1Password"
			printf "\n"
			show_diff "${tmp_remote}" "${target_path}" "1password: ${op_item}" "local: ${target}"
			printf "\n"
			show_key_analysis "${tmp_remote}" "${target_path}" "1password" "local"
			printf "\n"
			rm -f "${tmp_remote}"

			local prompt_rc
			set +e
			prompt_user "1Password item \"${op_item}\"" "${tmp_remote}" "${target_path}" "1password: ${op_item}" "local: ${target}"
			prompt_rc=$?
			set -e
			if [[ ${prompt_rc} -ne 0 ]]; then
				info "Skipped ${target}"
				summary+=("${DIM}‚è≠${RESET} ${target} ‚Äî skipped")
				echo ""
				continue
			fi

			# Push via edit
			info "Running: op item edit \"${op_item}\" notesPlain=\"<content of ${target}>\""
			local file_content
			file_content=$(cat "${target_path}")
			if op item edit "${op_item}" notesPlain="${file_content}" </dev/null >/dev/null; then
				ok "Pushed ${target} ‚Üí 1Password"
				summary+=("${YELLOW}‚Üª${RESET} ${target} ‚Äî pushed to 1Password")
			else
				error "Failed to push ${target} to 1Password (see error above)"
				summary+=("${RED}‚úñ${RESET} ${target} ‚Äî push failed")
			fi
		else
			# Item doesn't exist ‚Äî create it
			warn "1Password item \"${op_item}\" does not exist"

			if ${FORCE}; then
				: # proceed to create
			else
				printf '  %sCreate it now?%s [y]es / [n]o: ' "${BOLD}" "${RESET}"
				read -r choice </dev/tty
				if [[ ! ${choice} =~ ^[yY] ]]; then
					info "Skipped ${target}"
					summary+=("${DIM}‚è≠${RESET} ${target} ‚Äî skipped")
					echo ""
					continue
				fi
			fi

			info "Running: op item create --category \"Secure Note\" --title \"${op_item}\" notesPlain=\"<content of ${target}>\""
			local file_content
			file_content=$(cat "${target_path}")
			if op item create --category "Secure Note" --title "${op_item}" notesPlain="${file_content}" </dev/null >/dev/null; then
				ok "Created 1Password item \"${op_item}\""
				summary+=("${GREEN}‚úî${RESET} ${target} ‚Äî created in 1Password")
			else
				error "Failed to create \"${op_item}\" in 1Password (see error above)"
				summary+=("${RED}‚úñ${RESET} ${target} ‚Äî create failed")
			fi
		fi

		echo ""
	done <<<"${config_lines}"

	print_summary "${count}" "${summary[@]}"
}

cmd_diff() {
	printf '\n%süîç Comparing local .env files with 1Password%s\n' "${BOLD}" "${RESET}"
	printf '%sConfig: %s%s\n\n' "${DIM}" "${CONFIG_FILE}" "${RESET}"

	local count=0
	local has_diff=false

	local config_lines
	config_lines=$(parse_config)

	while IFS=$'\t' read -r op_item target; do
		count=$((count + 1))
		local target_path="${PWD}/${target}"

		printf '%s‚îÅ‚îÅ‚îÅ [%s] %s%s\n' "${BOLD}" "${count}" "${target}" "${RESET}"
		info "1Password item: ${op_item}"

		# Fetch from 1Password
		local env_data fetch_rc
		set +e
		env_data=$(fetch_from_op "${op_item}")
		fetch_rc=$?
		set -e
		if [[ ${fetch_rc} -ne 0 ]]; then
			echo ""
			continue
		fi

		local tmp_file
		tmp_file=$(mktemp)
		printf '%s\n' "${env_data}" >"${tmp_file}"

		if [[ ! -f ${target_path} ]]; then
			warn "Local file does not exist (would be created on pull)"
			has_diff=true
			rm -f "${tmp_file}"
			echo ""
			continue
		fi

		if diff -q "${target_path}" "${tmp_file}" &>/dev/null; then
			ok "In sync"
		else
			has_diff=true
			warn "Differences found"
			printf "\n"
			show_diff "${target_path}" "${tmp_file}" "local: ${target}" "1password: ${op_item}"
			printf "\n"
			show_key_analysis "${target_path}" "${tmp_file}" "local" "1password"
		fi

		rm -f "${tmp_file}"
		echo ""
	done <<<"${config_lines}"

	if [[ ${count} -eq 0 ]]; then
		warn "No entries found in ${CONFIG_FILE}."
	elif ! ${has_diff}; then
		printf '\n%sAll .env files are in sync with 1Password.%s\n\n' "${GREEN}${BOLD}" "${RESET}"
	fi
}

# --- Summary ----------------------------------------------------------------

print_summary() {
	local count="$1"
	shift

	if [[ ${count} -eq 0 ]]; then
		warn "No entries found in ${CONFIG_FILE}. Nothing to do."
		return
	fi

	printf '%s‚îÅ‚îÅ‚îÅ Summary ‚îÅ‚îÅ‚îÅ%s\n' "${BOLD}" "${RESET}"
	for line in "$@"; do
		printf "  %b\n" "${line}"
	done
	printf "\n"
}

# --- Preflight checks -------------------------------------------------------

# op CLI is required for pull/push/diff but not for init/update/help/version
check_op_installed() {
	if ! command -v op &>/dev/null; then
		error "1Password CLI (op) is not installed or not in PATH."
		echo "  Install: https://developer.1password.com/docs/cli/get-started/"
		exit 1
	fi
}

# --- Arg parsing ------------------------------------------------------------

COMMAND="${1-}"
shift || true

# Save remaining args for potential re-exec after update
ORIGINAL_ARGS=("${COMMAND}" "$@")

for arg in "$@"; do
	case "${arg}" in
	--force | -f) FORCE=true ;;
	--help | -h)
		usage
		exit 0
		;;
	--version | -v)
		echo "dotenv-sync v${VERSION}"
		exit 0
		;;
	*)
		error "Unknown option: ${arg}"
		usage
		exit 1
		;;
	esac
done

# Check for updates before running any command (except update/init itself)
if [[ "${COMMAND}" != "update" && "${COMMAND}" != "init" && "${COMMAND}" != "--version" && "${COMMAND}" != "-v" ]]; then
	check_for_updates "${ORIGINAL_ARGS[@]}"
fi

# Config file is required for pull/push/diff (but not for init, update, help, version)
case "${COMMAND}" in
pull | push | diff)
	check_op_installed
	if [[ ! -f ${CONFIG_FILE} ]]; then
		error "Config file not found: ${CONFIG_FILE}"
		info "Run 'dotenv-sync init' to create one, or see 'dotenv-sync --help' for an example."
		exit 1
	fi
	;;
esac

case "${COMMAND}" in
pull) cmd_pull ;;
push) cmd_push ;;
diff) cmd_diff ;;
init) cmd_init ;;
update) cmd_update ;;
--help | -h | "")
	usage
	exit 0
	;;
--version | -v)
	echo "dotenv-sync v${VERSION}"
	exit 0
	;;
*)
	error "Unknown command: ${COMMAND}"
	usage
	exit 1
	;;
esac
